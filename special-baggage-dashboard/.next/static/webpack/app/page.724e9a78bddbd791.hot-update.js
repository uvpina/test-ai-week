"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api/loading-records.ts":
/*!************************************!*\
  !*** ./lib/api/loading-records.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchLoadingRecords: function() { return /* binding */ fetchLoadingRecords; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\n// Backend API URL - adjust port if your Spring Boot app runs on a different port\nconst API_BASE_URL = \"http://localhost:8080/api\";\n/**\n * Converts a local date to UTC ISO string format with the specific time parts\n * @param hoursOffset - Hours to offset from current time (positive for future, negative for past)\n * @returns UTC date string in ISO format\n */ function getUTCDateString(hoursOffset) {\n    const date = new Date();\n    // Add or subtract the specified hours\n    date.setHours(date.getHours() + hoursOffset);\n    // Convert to UTC ISO string\n    return date.toISOString();\n}\nconst fetchLoadingRecords = async (filters)=>{\n    try {\n        // Set default time ranges if not provided\n        const pastHours = filters.timeRangePast || 24;\n        const futureHours = filters.timeRangeFuture || 24;\n        // Calculate the UTC dates for the time range\n        const fromDate = getUTCDateString(-pastHours); // Past time (negative offset)\n        const toDate = getUTCDateString(futureHours); // Future time (positive offset)\n        console.log(\"Fetching baggage records from \".concat(fromDate, \" to \").concat(toDate));\n        // Prepare params with time range and filters\n        const params = {\n            from: fromDate,\n            to: toDate,\n            flightStatus: filters.flightStatus !== \"All\" ? filters.flightStatus : undefined,\n            passengerType: filters.passengerType !== \"All\" ? filters.passengerType : undefined,\n            baggageStatus: filters.baggageStatus !== \"All\" ? filters.baggageStatus : undefined\n        };\n        // Make actual API call to the backend using the new endpoint\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_BASE_URL, \"/get-special-baggage\"), {\n            params: params\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching special baggage records:\", error);\n        throw error;\n    }\n}; /* \n// This is the original function with mock data that has been commented out\nexport const fetchLoadingRecords = async (filters: FilterOptions): Promise<LoadingRecord[]> => {\n  // Simulate API call with mock data for now\n  // In a real app, this would be:\n  // return axios.get('/api/loading-records', { params: filters }).then(res => res.data);\n  \n  // Mock data that matches the UI design\n  const mockData: LoadingRecord[] = [\n    {\n      flightNumber: 'DL123',\n      seat: '8A',\n      baggageType: 'pet',\n      status: 'not_loaded',\n      hasBoarded: true,\n      departureDateTime: '28/FEB 23:30',\n      flightStand: 'A23B5',\n      bagtag: 'BAG1234'\n    },\n    {\n      flightNumber: 'AA245',\n      seat: '12C',\n      baggageType: 'wheelchair',\n      status: 'not_loaded',\n      hasBoarded: true,\n      departureDateTime: '01/MAR 06:15',\n      flightStand: 'C12D4',\n      bagtag: 'BAG5678'\n    },\n    {\n      flightNumber: 'UA360',\n      seat: '3F',\n      baggageType: 'weapon',\n      status: 'loaded',\n      hasBoarded: false,\n      departureDateTime: '28/FEB 15:45',\n      flightStand: 'B45F2',\n      bagtag: 'BAG9012'\n    },\n    {\n      flightNumber: 'BA789',\n      seat: '5D',\n      baggageType: 'wheelchair',\n      status: 'loaded',\n      hasBoarded: true,\n      departureDateTime: '02/MAR 10:20',\n      flightStand: 'E17A3',\n      bagtag: 'BAG3456'\n    },\n    {\n      flightNumber: 'LH550',\n      seat: '17A',\n      baggageType: 'pet',\n      status: 'not_loaded',\n      hasBoarded: false,\n      departureDateTime: '01/MAR 14:55',\n      flightStand: 'D31C7',\n      bagtag: 'BAG7890'\n    },\n    {\n      flightNumber: 'AC410',\n      seat: '20B',\n      baggageType: 'weapon',\n      status: 'not_loaded',\n      hasBoarded: true,\n      departureDateTime: '28/FEB 22:10',\n      flightStand: 'F09E1',\n      bagtag: 'BAG2345'\n    },\n    {\n      flightNumber: 'AC410',\n      seat: '20B',\n      baggageType: 'pet',\n      status: 'not_loaded',\n      hasBoarded: false,\n      departureDateTime: '28/FEB 22:10',\n      flightStand: 'F09E1',\n      bagtag: 'BAG6789'\n    }\n  ];\n\n  // Apply filters\n  let filteredData = [...mockData];\n  \n  // Add filter for 'Boarded' and 'Not Boarded'\n  if (filters.flightStatus !== 'All') {\n    filteredData = filteredData.filter(record => {\n      if (filters.flightStatus === 'Boarded') return record.hasBoarded;\n      if (filters.flightStatus === 'Not Boarded') return !record.hasBoarded;\n      return true;\n    });\n  }\n  \n  if (filters.passengerType !== 'All') {\n    filteredData = filteredData.filter(record => {\n      if (filters.passengerType === 'Pet') return record.baggageType === 'pet';\n      if (filters.passengerType === 'Wheelchair') return record.baggageType === 'wheelchair';\n      if (filters.passengerType === 'Weapon') return record.baggageType === 'weapon';\n      return true;\n    });\n  }\n  \n  if (filters.baggageStatus !== 'All') {\n    filteredData = filteredData.filter(record => {\n      if (filters.baggageStatus === 'Loaded') return record.status === 'loaded';\n      if (filters.baggageStatus === 'Not Loaded') return record.status === 'not_loaded';\n      return true;\n    });\n  }\n\n  // Sort by departure date/time\n  filteredData.sort((a, b) => {\n    // Extract date and time components\n    const [dateA, timeA] = a.departureDateTime.split(' ');\n    const [dateB, timeB] = b.departureDateTime.split(' ');\n\n    // Parse dates (DD/MMM format)\n    const [dayA, monthA] = dateA.split('/');\n    const [dayB, monthB] = dateB.split('/');\n\n    // Convert month names to numbers\n    const monthsMap: Record<string, number> = {\n      'JAN': 0, 'FEB': 1, 'MAR': 2, 'APR': 3, 'MAY': 4, 'JUN': 5,\n      'JUL': 6, 'AUG': 7, 'SEP': 8, 'OCT': 9, 'NOV': 10, 'DEC': 11\n    };\n\n    // Create Date objects for comparison\n    const dateObjA = new Date(new Date().getFullYear(), monthsMap[monthA], parseInt(dayA), \n      parseInt(timeA.split(':')[0]), parseInt(timeA.split(':')[1]));\n    const dateObjB = new Date(new Date().getFullYear(), monthsMap[monthB], parseInt(dayB), \n      parseInt(timeB.split(':')[0]), parseInt(timeB.split(':')[1]));\n\n    return dateObjA.getTime() - dateObjB.getTime();\n  });\n\n  return new Promise(resolve => {\n    // Simulate network delay\n    setTimeout(() => {\n      resolve(filteredData);\n    }, 500);\n  });\n};\n*/ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkvbG9hZGluZy1yZWNvcmRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBCO0FBcUIxQixpRkFBaUY7QUFDakYsTUFBTUMsZUFBZTtBQUVyQjs7OztDQUlDLEdBQ0QsU0FBU0MsaUJBQWlCQyxXQUFtQjtJQUMzQyxNQUFNQyxPQUFPLElBQUlDO0lBQ2pCLHNDQUFzQztJQUN0Q0QsS0FBS0UsUUFBUSxDQUFDRixLQUFLRyxRQUFRLEtBQUtKO0lBQ2hDLDRCQUE0QjtJQUM1QixPQUFPQyxLQUFLSSxXQUFXO0FBQ3pCO0FBRU8sTUFBTUMsc0JBQXNCLE9BQU9DO0lBQ3hDLElBQUk7UUFDRiwwQ0FBMEM7UUFDMUMsTUFBTUMsWUFBWUQsUUFBUUUsYUFBYSxJQUFJO1FBQzNDLE1BQU1DLGNBQWNILFFBQVFJLGVBQWUsSUFBSTtRQUUvQyw2Q0FBNkM7UUFDN0MsTUFBTUMsV0FBV2IsaUJBQWlCLENBQUNTLFlBQVksOEJBQThCO1FBQzdFLE1BQU1LLFNBQVNkLGlCQUFpQlcsY0FBZSxnQ0FBZ0M7UUFFL0VJLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBZ0RGLE9BQWZELFVBQVMsUUFBYSxPQUFQQztRQUU1RCw2Q0FBNkM7UUFDN0MsTUFBTUcsU0FBUztZQUNiQyxNQUFNTDtZQUNOTSxJQUFJTDtZQUNKTSxjQUFjWixRQUFRWSxZQUFZLEtBQUssUUFBUVosUUFBUVksWUFBWSxHQUFHQztZQUN0RUMsZUFBZWQsUUFBUWMsYUFBYSxLQUFLLFFBQVFkLFFBQVFjLGFBQWEsR0FBR0Q7WUFDekVFLGVBQWVmLFFBQVFlLGFBQWEsS0FBSyxRQUFRZixRQUFRZSxhQUFhLEdBQUdGO1FBQzNFO1FBRUEsNkRBQTZEO1FBQzdELE1BQU1HLFdBQVcsTUFBTTFCLDZDQUFLQSxDQUFDMkIsR0FBRyxDQUFDLEdBQWdCLE9BQWIxQixjQUFhLHlCQUF1QjtZQUN0RWtCLFFBQVFBO1FBQ1Y7UUFFQSxPQUFPTyxTQUFTRSxJQUFJO0lBQ3RCLEVBQUUsT0FBT0MsT0FBTztRQUNkWixRQUFRWSxLQUFLLENBQUMsMkNBQTJDQTtRQUN6RCxNQUFNQTtJQUNSO0FBQ0YsRUFBRSxDQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOElBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkvbG9hZGluZy1yZWNvcmRzLnRzPzU4MWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuZXhwb3J0IGludGVyZmFjZSBMb2FkaW5nUmVjb3JkIHtcbiAgZmxpZ2h0TnVtYmVyOiBzdHJpbmc7XG4gIHNlYXQ6IHN0cmluZztcbiAgYmFnZ2FnZVR5cGU6ICdwZXQnIHwgJ3doZWVsY2hhaXInIHwgJ3dlYXBvbic7XG4gIHN0YXR1czogJ2xvYWRlZCcgfCAnbm90X2xvYWRlZCc7XG4gIGhhc0JvYXJkZWQ6IGJvb2xlYW47XG4gIGRlcGFydHVyZURhdGVUaW1lOiBzdHJpbmc7IC8vIEZvcm1hdDogREQvTU1NIEhIOk1NIChlLmcuLCAyOC9GRUIgMjM6MzApXG4gIGZsaWdodFN0YW5kOiBzdHJpbmc7IC8vIDUgYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgYmFndGFnOiBzdHJpbmc7IC8vIEJhZ2dhZ2UgaWRlbnRpZmljYXRpb24gbnVtYmVyXG59XG5cbmludGVyZmFjZSBGaWx0ZXJPcHRpb25zIHtcbiAgZmxpZ2h0U3RhdHVzOiBzdHJpbmc7XG4gIHBhc3NlbmdlclR5cGU6IHN0cmluZztcbiAgYmFnZ2FnZVN0YXR1czogc3RyaW5nO1xuICB0aW1lUmFuZ2VQYXN0PzogbnVtYmVyO1xuICB0aW1lUmFuZ2VGdXR1cmU/OiBudW1iZXI7XG59XG5cbi8vIEJhY2tlbmQgQVBJIFVSTCAtIGFkanVzdCBwb3J0IGlmIHlvdXIgU3ByaW5nIEJvb3QgYXBwIHJ1bnMgb24gYSBkaWZmZXJlbnQgcG9ydFxuY29uc3QgQVBJX0JBU0VfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9hcGknO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbG9jYWwgZGF0ZSB0byBVVEMgSVNPIHN0cmluZyBmb3JtYXQgd2l0aCB0aGUgc3BlY2lmaWMgdGltZSBwYXJ0c1xuICogQHBhcmFtIGhvdXJzT2Zmc2V0IC0gSG91cnMgdG8gb2Zmc2V0IGZyb20gY3VycmVudCB0aW1lIChwb3NpdGl2ZSBmb3IgZnV0dXJlLCBuZWdhdGl2ZSBmb3IgcGFzdClcbiAqIEByZXR1cm5zIFVUQyBkYXRlIHN0cmluZyBpbiBJU08gZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoaG91cnNPZmZzZXQ6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAvLyBBZGQgb3Igc3VidHJhY3QgdGhlIHNwZWNpZmllZCBob3Vyc1xuICBkYXRlLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIGhvdXJzT2Zmc2V0KTtcbiAgLy8gQ29udmVydCB0byBVVEMgSVNPIHN0cmluZ1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hMb2FkaW5nUmVjb3JkcyA9IGFzeW5jIChmaWx0ZXJzOiBGaWx0ZXJPcHRpb25zKTogUHJvbWlzZTxMb2FkaW5nUmVjb3JkW10+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBTZXQgZGVmYXVsdCB0aW1lIHJhbmdlcyBpZiBub3QgcHJvdmlkZWRcbiAgICBjb25zdCBwYXN0SG91cnMgPSBmaWx0ZXJzLnRpbWVSYW5nZVBhc3QgfHwgMjQ7XG4gICAgY29uc3QgZnV0dXJlSG91cnMgPSBmaWx0ZXJzLnRpbWVSYW5nZUZ1dHVyZSB8fCAyNDtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIFVUQyBkYXRlcyBmb3IgdGhlIHRpbWUgcmFuZ2VcbiAgICBjb25zdCBmcm9tRGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoLXBhc3RIb3Vycyk7IC8vIFBhc3QgdGltZSAobmVnYXRpdmUgb2Zmc2V0KVxuICAgIGNvbnN0IHRvRGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoZnV0dXJlSG91cnMpOyAgLy8gRnV0dXJlIHRpbWUgKHBvc2l0aXZlIG9mZnNldClcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgYmFnZ2FnZSByZWNvcmRzIGZyb20gJHtmcm9tRGF0ZX0gdG8gJHt0b0RhdGV9YCk7XG4gICAgXG4gICAgLy8gUHJlcGFyZSBwYXJhbXMgd2l0aCB0aW1lIHJhbmdlIGFuZCBmaWx0ZXJzXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZnJvbTogZnJvbURhdGUsXG4gICAgICB0bzogdG9EYXRlLFxuICAgICAgZmxpZ2h0U3RhdHVzOiBmaWx0ZXJzLmZsaWdodFN0YXR1cyAhPT0gJ0FsbCcgPyBmaWx0ZXJzLmZsaWdodFN0YXR1cyA6IHVuZGVmaW5lZCxcbiAgICAgIHBhc3NlbmdlclR5cGU6IGZpbHRlcnMucGFzc2VuZ2VyVHlwZSAhPT0gJ0FsbCcgPyBmaWx0ZXJzLnBhc3NlbmdlclR5cGUgOiB1bmRlZmluZWQsXG4gICAgICBiYWdnYWdlU3RhdHVzOiBmaWx0ZXJzLmJhZ2dhZ2VTdGF0dXMgIT09ICdBbGwnID8gZmlsdGVycy5iYWdnYWdlU3RhdHVzIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBcbiAgICAvLyBNYWtlIGFjdHVhbCBBUEkgY2FsbCB0byB0aGUgYmFja2VuZCB1c2luZyB0aGUgbmV3IGVuZHBvaW50XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7QVBJX0JBU0VfVVJMfS9nZXQtc3BlY2lhbC1iYWdnYWdlYCwgeyBcbiAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc3BlY2lhbCBiYWdnYWdlIHJlY29yZHM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKiBcbi8vIFRoaXMgaXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggbW9jayBkYXRhIHRoYXQgaGFzIGJlZW4gY29tbWVudGVkIG91dFxuZXhwb3J0IGNvbnN0IGZldGNoTG9hZGluZ1JlY29yZHMgPSBhc3luYyAoZmlsdGVyczogRmlsdGVyT3B0aW9ucyk6IFByb21pc2U8TG9hZGluZ1JlY29yZFtdPiA9PiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBjYWxsIHdpdGggbW9jayBkYXRhIGZvciBub3dcbiAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZTpcbiAgLy8gcmV0dXJuIGF4aW9zLmdldCgnL2FwaS9sb2FkaW5nLXJlY29yZHMnLCB7IHBhcmFtczogZmlsdGVycyB9KS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XG4gIFxuICAvLyBNb2NrIGRhdGEgdGhhdCBtYXRjaGVzIHRoZSBVSSBkZXNpZ25cbiAgY29uc3QgbW9ja0RhdGE6IExvYWRpbmdSZWNvcmRbXSA9IFtcbiAgICB7XG4gICAgICBmbGlnaHROdW1iZXI6ICdETDEyMycsXG4gICAgICBzZWF0OiAnOEEnLFxuICAgICAgYmFnZ2FnZVR5cGU6ICdwZXQnLFxuICAgICAgc3RhdHVzOiAnbm90X2xvYWRlZCcsXG4gICAgICBoYXNCb2FyZGVkOiB0cnVlLFxuICAgICAgZGVwYXJ0dXJlRGF0ZVRpbWU6ICcyOC9GRUIgMjM6MzAnLFxuICAgICAgZmxpZ2h0U3RhbmQ6ICdBMjNCNScsXG4gICAgICBiYWd0YWc6ICdCQUcxMjM0J1xuICAgIH0sXG4gICAge1xuICAgICAgZmxpZ2h0TnVtYmVyOiAnQUEyNDUnLFxuICAgICAgc2VhdDogJzEyQycsXG4gICAgICBiYWdnYWdlVHlwZTogJ3doZWVsY2hhaXInLFxuICAgICAgc3RhdHVzOiAnbm90X2xvYWRlZCcsXG4gICAgICBoYXNCb2FyZGVkOiB0cnVlLFxuICAgICAgZGVwYXJ0dXJlRGF0ZVRpbWU6ICcwMS9NQVIgMDY6MTUnLFxuICAgICAgZmxpZ2h0U3RhbmQ6ICdDMTJENCcsXG4gICAgICBiYWd0YWc6ICdCQUc1Njc4J1xuICAgIH0sXG4gICAge1xuICAgICAgZmxpZ2h0TnVtYmVyOiAnVUEzNjAnLFxuICAgICAgc2VhdDogJzNGJyxcbiAgICAgIGJhZ2dhZ2VUeXBlOiAnd2VhcG9uJyxcbiAgICAgIHN0YXR1czogJ2xvYWRlZCcsXG4gICAgICBoYXNCb2FyZGVkOiBmYWxzZSxcbiAgICAgIGRlcGFydHVyZURhdGVUaW1lOiAnMjgvRkVCIDE1OjQ1JyxcbiAgICAgIGZsaWdodFN0YW5kOiAnQjQ1RjInLFxuICAgICAgYmFndGFnOiAnQkFHOTAxMidcbiAgICB9LFxuICAgIHtcbiAgICAgIGZsaWdodE51bWJlcjogJ0JBNzg5JyxcbiAgICAgIHNlYXQ6ICc1RCcsXG4gICAgICBiYWdnYWdlVHlwZTogJ3doZWVsY2hhaXInLFxuICAgICAgc3RhdHVzOiAnbG9hZGVkJyxcbiAgICAgIGhhc0JvYXJkZWQ6IHRydWUsXG4gICAgICBkZXBhcnR1cmVEYXRlVGltZTogJzAyL01BUiAxMDoyMCcsXG4gICAgICBmbGlnaHRTdGFuZDogJ0UxN0EzJyxcbiAgICAgIGJhZ3RhZzogJ0JBRzM0NTYnXG4gICAgfSxcbiAgICB7XG4gICAgICBmbGlnaHROdW1iZXI6ICdMSDU1MCcsXG4gICAgICBzZWF0OiAnMTdBJyxcbiAgICAgIGJhZ2dhZ2VUeXBlOiAncGV0JyxcbiAgICAgIHN0YXR1czogJ25vdF9sb2FkZWQnLFxuICAgICAgaGFzQm9hcmRlZDogZmFsc2UsXG4gICAgICBkZXBhcnR1cmVEYXRlVGltZTogJzAxL01BUiAxNDo1NScsXG4gICAgICBmbGlnaHRTdGFuZDogJ0QzMUM3JyxcbiAgICAgIGJhZ3RhZzogJ0JBRzc4OTAnXG4gICAgfSxcbiAgICB7XG4gICAgICBmbGlnaHROdW1iZXI6ICdBQzQxMCcsXG4gICAgICBzZWF0OiAnMjBCJyxcbiAgICAgIGJhZ2dhZ2VUeXBlOiAnd2VhcG9uJyxcbiAgICAgIHN0YXR1czogJ25vdF9sb2FkZWQnLFxuICAgICAgaGFzQm9hcmRlZDogdHJ1ZSxcbiAgICAgIGRlcGFydHVyZURhdGVUaW1lOiAnMjgvRkVCIDIyOjEwJyxcbiAgICAgIGZsaWdodFN0YW5kOiAnRjA5RTEnLFxuICAgICAgYmFndGFnOiAnQkFHMjM0NSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGZsaWdodE51bWJlcjogJ0FDNDEwJyxcbiAgICAgIHNlYXQ6ICcyMEInLFxuICAgICAgYmFnZ2FnZVR5cGU6ICdwZXQnLFxuICAgICAgc3RhdHVzOiAnbm90X2xvYWRlZCcsXG4gICAgICBoYXNCb2FyZGVkOiBmYWxzZSxcbiAgICAgIGRlcGFydHVyZURhdGVUaW1lOiAnMjgvRkVCIDIyOjEwJyxcbiAgICAgIGZsaWdodFN0YW5kOiAnRjA5RTEnLFxuICAgICAgYmFndGFnOiAnQkFHNjc4OSdcbiAgICB9XG4gIF07XG5cbiAgLy8gQXBwbHkgZmlsdGVyc1xuICBsZXQgZmlsdGVyZWREYXRhID0gWy4uLm1vY2tEYXRhXTtcbiAgXG4gIC8vIEFkZCBmaWx0ZXIgZm9yICdCb2FyZGVkJyBhbmQgJ05vdCBCb2FyZGVkJ1xuICBpZiAoZmlsdGVycy5mbGlnaHRTdGF0dXMgIT09ICdBbGwnKSB7XG4gICAgZmlsdGVyZWREYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihyZWNvcmQgPT4ge1xuICAgICAgaWYgKGZpbHRlcnMuZmxpZ2h0U3RhdHVzID09PSAnQm9hcmRlZCcpIHJldHVybiByZWNvcmQuaGFzQm9hcmRlZDtcbiAgICAgIGlmIChmaWx0ZXJzLmZsaWdodFN0YXR1cyA9PT0gJ05vdCBCb2FyZGVkJykgcmV0dXJuICFyZWNvcmQuaGFzQm9hcmRlZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIFxuICBpZiAoZmlsdGVycy5wYXNzZW5nZXJUeXBlICE9PSAnQWxsJykge1xuICAgIGZpbHRlcmVkRGF0YSA9IGZpbHRlcmVkRGF0YS5maWx0ZXIocmVjb3JkID0+IHtcbiAgICAgIGlmIChmaWx0ZXJzLnBhc3NlbmdlclR5cGUgPT09ICdQZXQnKSByZXR1cm4gcmVjb3JkLmJhZ2dhZ2VUeXBlID09PSAncGV0JztcbiAgICAgIGlmIChmaWx0ZXJzLnBhc3NlbmdlclR5cGUgPT09ICdXaGVlbGNoYWlyJykgcmV0dXJuIHJlY29yZC5iYWdnYWdlVHlwZSA9PT0gJ3doZWVsY2hhaXInO1xuICAgICAgaWYgKGZpbHRlcnMucGFzc2VuZ2VyVHlwZSA9PT0gJ1dlYXBvbicpIHJldHVybiByZWNvcmQuYmFnZ2FnZVR5cGUgPT09ICd3ZWFwb24nO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgXG4gIGlmIChmaWx0ZXJzLmJhZ2dhZ2VTdGF0dXMgIT09ICdBbGwnKSB7XG4gICAgZmlsdGVyZWREYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihyZWNvcmQgPT4ge1xuICAgICAgaWYgKGZpbHRlcnMuYmFnZ2FnZVN0YXR1cyA9PT0gJ0xvYWRlZCcpIHJldHVybiByZWNvcmQuc3RhdHVzID09PSAnbG9hZGVkJztcbiAgICAgIGlmIChmaWx0ZXJzLmJhZ2dhZ2VTdGF0dXMgPT09ICdOb3QgTG9hZGVkJykgcmV0dXJuIHJlY29yZC5zdGF0dXMgPT09ICdub3RfbG9hZGVkJztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gU29ydCBieSBkZXBhcnR1cmUgZGF0ZS90aW1lXG4gIGZpbHRlcmVkRGF0YS5zb3J0KChhLCBiKSA9PiB7XG4gICAgLy8gRXh0cmFjdCBkYXRlIGFuZCB0aW1lIGNvbXBvbmVudHNcbiAgICBjb25zdCBbZGF0ZUEsIHRpbWVBXSA9IGEuZGVwYXJ0dXJlRGF0ZVRpbWUuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBbZGF0ZUIsIHRpbWVCXSA9IGIuZGVwYXJ0dXJlRGF0ZVRpbWUuc3BsaXQoJyAnKTtcblxuICAgIC8vIFBhcnNlIGRhdGVzIChERC9NTU0gZm9ybWF0KVxuICAgIGNvbnN0IFtkYXlBLCBtb250aEFdID0gZGF0ZUEuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBbZGF5QiwgbW9udGhCXSA9IGRhdGVCLnNwbGl0KCcvJyk7XG5cbiAgICAvLyBDb252ZXJ0IG1vbnRoIG5hbWVzIHRvIG51bWJlcnNcbiAgICBjb25zdCBtb250aHNNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICAnSkFOJzogMCwgJ0ZFQic6IDEsICdNQVInOiAyLCAnQVBSJzogMywgJ01BWSc6IDQsICdKVU4nOiA1LFxuICAgICAgJ0pVTCc6IDYsICdBVUcnOiA3LCAnU0VQJzogOCwgJ09DVCc6IDksICdOT1YnOiAxMCwgJ0RFQyc6IDExXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBEYXRlIG9iamVjdHMgZm9yIGNvbXBhcmlzb25cbiAgICBjb25zdCBkYXRlT2JqQSA9IG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgbW9udGhzTWFwW21vbnRoQV0sIHBhcnNlSW50KGRheUEpLCBcbiAgICAgIHBhcnNlSW50KHRpbWVBLnNwbGl0KCc6JylbMF0pLCBwYXJzZUludCh0aW1lQS5zcGxpdCgnOicpWzFdKSk7XG4gICAgY29uc3QgZGF0ZU9iakIgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIG1vbnRoc01hcFttb250aEJdLCBwYXJzZUludChkYXlCKSwgXG4gICAgICBwYXJzZUludCh0aW1lQi5zcGxpdCgnOicpWzBdKSwgcGFyc2VJbnQodGltZUIuc3BsaXQoJzonKVsxXSkpO1xuXG4gICAgcmV0dXJuIGRhdGVPYmpBLmdldFRpbWUoKSAtIGRhdGVPYmpCLmdldFRpbWUoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIC8vIFNpbXVsYXRlIG5ldHdvcmsgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc29sdmUoZmlsdGVyZWREYXRhKTtcbiAgICB9LCA1MDApO1xuICB9KTtcbn07XG4qLyAiXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJnZXRVVENEYXRlU3RyaW5nIiwiaG91cnNPZmZzZXQiLCJkYXRlIiwiRGF0ZSIsInNldEhvdXJzIiwiZ2V0SG91cnMiLCJ0b0lTT1N0cmluZyIsImZldGNoTG9hZGluZ1JlY29yZHMiLCJmaWx0ZXJzIiwicGFzdEhvdXJzIiwidGltZVJhbmdlUGFzdCIsImZ1dHVyZUhvdXJzIiwidGltZVJhbmdlRnV0dXJlIiwiZnJvbURhdGUiLCJ0b0RhdGUiLCJjb25zb2xlIiwibG9nIiwicGFyYW1zIiwiZnJvbSIsInRvIiwiZmxpZ2h0U3RhdHVzIiwidW5kZWZpbmVkIiwicGFzc2VuZ2VyVHlwZSIsImJhZ2dhZ2VTdGF0dXMiLCJyZXNwb25zZSIsImdldCIsImRhdGEiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api/loading-records.ts\n"));

/***/ })

});